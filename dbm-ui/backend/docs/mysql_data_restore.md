数据恢复分为 `数据构造` 和 `数据回档`，构造/回档 又分为 `基于备份记录`和`基于指定时间`

## 数据构造
也叫定点构造/异地构造，是指安全的把数据恢复到 临时搭建的新集群，或者恢复到指定的集群中。

这个操作不会对备份的原有集群的数据产生影响。

构造类型 可根据是否需要恢复 binlog 分为
- `基于备份记录构造`
  可选 例行备份/全库备份单据/库表备份单据，所备份出来的一次数据，称为一份备份记录。
  - `例行备份`
    备份是每天凌晨生成的全备，可能为物理备份或者逻辑备份
  - `全库备份单据`
    备份记录会携带 单据号，其它与例行备份没有区别，全备可能为物理备份或者逻辑备份。
    一般在预计进行大批量数据修改前（如合服，大版本变更），主动发起的备份。
  - `库表备份单据`
    备份记录会携带 单据号，且只能是逻辑备份，因为只备份单据指定的库表。一般也是在风险操作之前进行备份。
    

- `基于指定时间构造`
  即 PIT 构造(Point-In-Time), 通过正向追加应用 binlog 使得数据恢复到某个时间点。
  基于指定时间恢复，为了防止非预期的结果，备份筛选不能是库表备份，必须是全备。
  一般情况，应用 binlog 需要原始数据是全备，因为 binlog 是实例级别不是库表级别。但如果在所有 binlog 都是 `binlog_format=ROW` 模式且 `FULL`，是可以通过 gomysqlbinlog 过滤出指定的库表变更记录，是可以只恢复部分库表到指定时间。

### 数据恢复到已有集群，涉及到对已有数据的影响：

- 恢复选择的是逻辑备份，如果数据恢复到的目标集群检查不为空(排除备份清档库)
  - 如果指定了库表，则自动生成库表清档单据
  - 如果没有指定库表，则把 databases 列出，并提示需要先手动删除
- 恢复选择的是物理备份，且目标实例不为空，则把 databases 列出，并提醒会删除所有数据。

### 数据恢复到已有集群，对已有集群的复制关系的影响：
**物理备份**，只能恢复全部数据，恢复之前可以 reset 掉同步信息，等主从恢复完成后，重新从 master 获取最新位点来给 slave change 过去

**逻辑备份**，恢复数据时会对会话关闭 sql_log_bin，不写 binlog。
  - 考虑到已有集群可能也是正式集群，为了在恢复期间发生故障能够切换成功，要一直维持原有的同步关系，不能 stop slave
  - 但现在全备数据恢复，会恢复 dba 系统库 infodba_schema ，如果不 stop slave 可能会导致 master_slave_heartbeat 主从心跳延迟检测表中断导致同步异常。
    所以在全备数据恢复场景(选择了逻辑不恢复，且是全备，且恢复库表选择器是恢复所有)，还是要 stop slave，同时加一条本地监控屏蔽规则。完成后直接 start  slave 即可

### 数据恢复的限制
**物理备份**，只能恢复全部数据，不能恢复指定的 db/table。物理备份 + binlog 可以把整个实例恢复到任意时间点。

**逻辑备份**，可以从中恢复指定的 db/table
  - 如果是库表备份，则不能指定时间点恢复。换句话说，指定时间点恢复，不能是库表备份记录
    如果是库表备份，且指定恢复部分库表，则单据无法检查指定的库表在备份是否存在，所以一般不建议这样使用。
  - 如果是恢复全备里的所有数据，可以指定任意时间点恢复
  - 如果是恢复全备里的部分库表，在符合 ROW&FULL 时，也可以指定任意时间点恢复

### 按时间自动匹配备份记录


### 对 slave 关系的处理

## 数据回档
也叫原地回档，分为备份数据 `定点回档` 和 `闪回`，会直接修改原集群里的数据。

定点回档到主要逻辑和现在，都与上面的 数据构造 相同，但也会保证权限得到恢复。

闪回，是一种只基于 binlog 反向应用来快速回滚 dml 的回档方式。要求原始集群是以 ROW&FULL 方式运行，且从当前时间回溯到闪回的时间(回档到目标时间) 期间对闪回的表不能有 ddl 字段变更。

由于是否有 ddl 变更最准确的就是从 binlog 里面解析一遍才能发现，所以单据无法提前判断。

闪回功能具体分为：
- 库表闪回
- 记录闪回
